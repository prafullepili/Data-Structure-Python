# List of algorithms and techniques that can help solve problems efficiently

## 1. Greedy Algorithms

- Idea: Make the locally optimal choice at each step.
- Applications:
  - Activity selection problem.
  - Huffman encoding.
  - Minimum Spanning Tree (Kruskal’s and Prim’s).

## 2. Divide and Conquer

- Idea: Divide the problem into sub-problems, solve them recursively, and combine the results.
- Applications:
  - Merge Sort.
  - Quick Sort.
  - Binary Search.
  - Closest Pair of Points.

## 3. Dynamic Programming (DP)

- Idea: Solve overlapping subproblems using memoization or tabulation.
- Applications:
  - Longest Common Subsequence (LCS).
  - 0/1 Knapsack Problem.
  - Matrix Chain Multiplication.
  - Coin Change Problem.

## 4. Backtracking

- Idea: Try all possible solutions and backtrack upon failure.
- Applications:
  - N-Queens problem.
  - Sudoku Solver.
  - Subset Generation.
  - Word Search in a Grid.

## 5. Sliding Window

-Idea: Maintain a window of elements that satisfies a given condition.

- Applications:
  - Longest substring with unique characters.
  - Maximum sum subarray of size k.
  - Minimum window substring.

## 6. Two-Pointer Technique

- Idea: Use two pointers to traverse an array for problems involving pairs or subarrays.
- Applications:
  - Finding pairs/triplets with a given sum.
  - Merging sorted arrays.
  - Sorting colors (Dutch National Flag Problem).

## 7. Recursion

- Idea: Solve problems by breaking them into smaller instances of the same problem.
- Applications:
  - Factorial computation.
  - Tower of Hanoi.
  - Generating permutations.

## 8. Graph Algorithms

- Key Techniques:
  - Breadth-First Search (BFS): Shortest path in an unweighted graph.
  - Depth-First Search (DFS): Pathfinding, cycle detection.
  - Dijkstra's Algorithm: Shortest path in a weighted graph.
  - Floyd-Warshall Algorithm: All-pairs shortest path.
  - Kruskal’s/Prim’s Algorithm: Minimum spanning tree.

## 9. Binary Search

- Idea: Efficiently find an element in a sorted array.
- Applications:
  - Find square root of a number.
  - Search in rotated sorted array.
  - Allocate minimum pages in book allocation.

## 10. Bit Manipulation

- Applications:
  - Find single non-repeating element.
  - Count set bits.
  - Subset generation using bitmasking.

## 11. Union-Find (Disjoint Set Union)

- Idea: Efficiently manage and merge disjoint sets.
- Applications:
  - Detect cycles in a graph.
  - Kruskal’s algorithm for MST.
  - Network connectivity.

## 12. Prefix Sum and Difference Arrays

- Applications:
  - Range sum queries.
  - Subarray sum problems.
  - Manipulate array efficiently in range operations.

## 13. Kadane’s Algorithm

- Idea: Find the maximum subarray sum in O(n) time.
- Applications:
  - Largest sum contiguous subarray.
  - Maximum profit in stock trading (1 transaction).

## 14. Monotonic Stack/Queue

- Applications:
  - Next Greater Element.
  - Largest rectangle in a histogram.
  - Sliding window maximum.

## 15. Sorting Algorithms

- Common Approaches:
  - Quick Sort.
  - Merge Sort.
  - Heap Sort.
  - Counting Sort.

## 16. Number Theory

- Applications:
  - Sieve of Eratosthenes for prime numbers.
  - GCD using Euclid’s Algorithm.
  - Modular arithmetic.
  - Chinese Remainder Theorem.

## 17. String Algorithms

- Applications:
  - KMP (Knuth-Morris-Pratt) for pattern matching.
  - Rabin-Karp Algorithm.
  - Z Algorithm for substring search.
  - Trie for prefix matching.

## 18. Segment Tree and Fenwick Tree

- Applications:
  - Range minimum/maximum queries.
  - Point updates and range queries.
  - 2D range queries.

## 19. Mathematical Techniques

- Applications:
  - Fast Exponentiation.
  - Matrix Exponentiation.
  - Newton-Raphson for root finding.

## 20. Heuristic and Optimization Techniques

- Applications:
  - Simulated Annealing.
  - Genetic Algorithms.
  - Gradient Descent.
